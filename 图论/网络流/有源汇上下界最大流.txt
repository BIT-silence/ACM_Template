// 求有源汇上下界最大流
// st[i]记录从i出发的流下界之和，ed[i]记录到达i的流的下界之和
// 返回-1表示不存在可行流

#include <iostream>
#include <cstdio>
#include <cstring>

#define MAXV 1024
#define MAXE 100010
#define INF 0x3F3F3F3F

using namespace std;

template<typename F = int>
struct MaxFlow {
    struct Edge {
        int ed, nxt;
        F flow;
        Edge() {}
        Edge(int e, int n, F f) : ed(e), nxt(n), flow(f) {}
    } edge[MAXE];

    int head[MAXV], nV, nE;
    int dis[MAXV], pre[MAXV], arc[MAXV], cur[MAXV], cnt[MAXV];
    F his[MAXV], st[MAXV], ed[MAXV];

    void init(int v) {
        memset(head, -1, sizeof(head));
        memset(st, 0, sizeof(st));
        memset(ed, 0, sizeof(ed));
        nV = v + 2; nE = 0;
    }

    void addEdge(int a, int b, F f) {
        edge[nE] = Edge(b, head[a], f); head[a] = nE++;
        edge[nE] = Edge(a, head[b], 0); head[b] = nE++;
    }

    void addFlow(int a, int b, int low, int high) {
        addEdge(a, b, high - low);
        st[a] += low; ed[b] += low;
    }

    F sap(int src, int dst) {
        int x, y, i, m;
        F curFlow = INF, totFlow = 0;
        bool flag;

        memset(dis, 0, sizeof(dis));
        memset(cnt, 0, sizeof(cnt));
        memcpy(cur, head, sizeof(cur));
        for (cnt[0] = nV, x = src; dis[src] < nV; ) {
            his[x] = curFlow; flag = false;
            for (i = cur[x]; ~i; i = edge[i].nxt) {
                if (edge[i].flow && dis[x] == dis[y = edge[i].ed] + 1) {
                    flag = true; curFlow = min(curFlow, edge[i].flow);
                    pre[y] = x; arc[y] = cur[x] = i;
                    if ((x = y) == dst) {
                        for (totFlow += curFlow; x != src; x = pre[x]) {
                            edge[arc[x]].flow -= curFlow;
                            edge[arc[x] ^ 1].flow += curFlow;
                        }
                        curFlow = INF;
                    }
                    break;
                }
            }
            if (!flag) {
                for (m = nV - 1, i = cur[x] = head[x]; ~i; i = edge[i].nxt) {
                    if (edge[i].flow && dis[y = edge[i].ed] < m) {
                        m = dis[y]; cur[x] = i;
                    }
                }
                if (!(--cnt[dis[x]])) break;
                ++cnt[dis[x] = m + 1];
                if (x != src) curFlow = his[x = pre[x]];
            }
        }

        return totFlow;
    }

    int maxFlow(int src, int dst) {
        int i, x = nV - 2, y = nV - 1, sum = 0;

        for (i = 0; i < nV - 2; ++i) {
            if (st[i]) addEdge(i, x, st[i]);
            if (ed[i]) addEdge(y, i, ed[i]);
            sum += st[i];
        }
        addEdge(dst, src, INF);
        if (sap(y, x) < sum) return -1;

        return edge[nE - 1].flow + sap(src, dst);
    }
};

MaxFlow<> graph;

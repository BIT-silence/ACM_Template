//sap算法求最大流，src为源点，dst为汇点，点编号从0开始

#include <iostream>
#include <cstdio>
#include <cstring>

#define MAXV 20010
#define MAXE 2000000
#define INF 0x3F3F3F3F

using namespace std;

typedef int F;

struct Edge {
    int ed, next;
    F flow;
} edge[MAXE];

int head[MAXV], nEdge;
int d[MAXV], pre[MAXV], path[MAXV], cur[MAXV], vh[MAXV];
F his[MAXV];

inline void init() {
    memset(head, -1, sizeof(head));
    nEdge = 0;
}

inline void _addEdge(int a, int b, F flow) {
    edge[nEdge].ed = b;
    edge[nEdge].flow = flow;
    edge[nEdge].next = head[a];
    head[a] = nEdge++;
}

inline void addEdge(int a, int b, F flow) {
    _addEdge(a, b, flow);
    _addEdge(b, a, 0);
}

F sap(int v, int src, int dst) {
    int x, y, i, m;
    F nowFlow = INF, totalFlow = 0;
    bool flag;

    memset(d, 0, sizeof(d));
    memset(vh, 0, sizeof(vh));
    memcpy(cur, head, sizeof(cur));
    for (vh[0] = v, x = src; d[src] < v;) {
        his[x] = nowFlow; flag = false;
        for (i = cur[x]; ~i; i = edge[i].next) {
            if (edge[i].flow && d[x] == d[y = edge[i].ed] + 1) {
                flag = true;
                nowFlow = min(nowFlow, edge[i].flow);
                pre[y] = x; path[y] = cur[x] = i;
                if ((x = y) == dst) {
                    for (totalFlow += nowFlow; x != src; x = pre[x]) {
                        edge[path[x]].flow -= nowFlow;
                        edge[path[x] ^ 1].flow += nowFlow;
                    }
                    nowFlow = INF;
                }
                break;
            }
        }
        if (!flag) {
            for (m = v - 1, i = cur[x] = head[x]; ~i; i = edge[i].next) {
                if (edge[i].flow && d[y = edge[i].ed] < m) {
                    m = d[y]; cur[x] = i;
                }
            }
            if (!(--vh[d[x]])) break;
            ++vh[d[x] = m + 1];
            if (x != src) nowFlow = his[x = pre[x]];
        }
    }

    return totalFlow;
}
